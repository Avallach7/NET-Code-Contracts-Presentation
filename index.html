<!DOCTYPE html>
<html lang="en">

<head>
	<title>.NET Code Contracts</title>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href="template/layout.css" rel="stylesheet">
	<link href="template/theme.css" rel="stylesheet">
    <script src="template/highlight.min.js"></script>
	<script src="template/peer.min.js"></script>
	<script src="template/scripts.js"></script>
	<script src="template/peer.integration.js"></script>
</head>

<body>
	<section data-title=".NET Code Contracts" data-footer="Adam.Golebiowski @ NewVoiceMedia.com" class="title">
		<style>
			section.title>a.url {
				position: absolute;
				left: 3em;
				top: 18em;
			}
		</style>
		<a class="url" href="https://avallach.ovh/contracts">avallach.ovh/contracts</a>
	</section>
	<section data-title="Agenda" class="agenda"></section>
    <section data-title="Example code - interface and tests">
        <p>You need to implement/understand/debug some interface, but cannot guess from names what it should really do:
        <code>public interface IFibonacci
{
	bool IsFibonacci(int n);
	int GetNkLteEnbEarfcnAdj(int n);     // apparently specs and
	int GetCPlnPbrSchUeNtActNext(int n); // names are in Finnish
}</code>
            Unit tests operate on example data and may not provide enough information for implementator:
            <code>public class FibonacciTest : Fibonacci
{
	[Theory] [InlineData(0, 0)] [InlineData(8, 21)] [InlineData(17, 1597)]
	public void NkLteEnbEarfcnAdjIsCalculated(int n, int expectation)
	{
		Assert.Equal(expectation, GetNkLteEnbEarfcnAdj(n));
	}
	[Theory] [InlineData(0, 1)] [InlineData(13, 21)] [InlineData(987, 1597)]
	public void CPlnPbrSchUeNtActIsCalculated(int current, int expectedNext)
	{
		Assert.Equal(expectedNext, GetCPlnPbrSchUeNtActNext(current));
	}
}</code></p>
    </section>
    <section data-title="Example code - contract">
        <p>Contracts help to clearly express generic intention behind interface:
            <code>[ContractClassFor(typeof(IFibonacci))]
abstract class FibonacciContract : IFibonacci
{
	public int GetNkLteEnbEarfcnAdj(int n)
	{
		Requires(n &gt;= 0);
        Ensures(<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(Result<span class="irrelevant">&lt;int&gt;()</span>));
		Ensures(n &gt; 1 || Result<span class="irrelevant">&lt;int&gt;()</span> == n);
        Ensures(n &lt; 2 || Enumerable.Range(0, Result<span class="irrelevant">&lt;int&gt;()</span> + 1).Count(m =&gt; <span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(m)) == n);<span class="irrelevant">
        return default(int);</span>
	}

	public int GetCPlnPbrSchUeNtActNext(int n)
	{
		Requires(<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(n));
		Ensures(Result<span class="irrelevant">&lt;int&gt;()</span> &gt; n);
		Ensures(<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(Result<span class="irrelevant">&lt;int&gt;()</span>));
		Ensures(ForAll(n + 1, Result<span class="irrelevant">&lt;int&gt;()</span>, m =&gt; !<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(m)));<span class="irrelevant">
		return default(int);</span>
	}
}
</code></p>
    </section>
    <section data-title="Example code - contract">
        <p>Contracts help to clearly express generic intention behind interface:
            <code>[ContractClassFor(typeof(IFibonacci))]
abstract class FibonacciContract : IFibonacci
{
	public int GetNthFibonacci(int n)
	{
		Requires(n &gt;= 0);
        Ensures(<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(Result<span class="irrelevant">&lt;int&gt;()</span>));
		Ensures(n &gt; 1 || Result<span class="irrelevant">&lt;int&gt;()</span> == n);
        Ensures(n &lt; 2 || Enumerable.Range(0, Result<span class="irrelevant">&lt;int&gt;()</span> + 1).Count(m =&gt; <span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(m)) == n);<span class="irrelevant">
        return default(int);</span>
	}

	public int GetCPlnPbrSchUeNtActNext(int n)
	{
		Requires(<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(n));
		Ensures(Result<span class="irrelevant">&lt;int&gt;()</span> &gt; n);
		Ensures(<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(Result<span class="irrelevant">&lt;int&gt;()</span>));
		Ensures(ForAll(n + 1, Result<span class="irrelevant">&lt;int&gt;()</span>, m =&gt; !<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(m)));<span class="irrelevant">
		return default(int);</span>
	}
}
</code></p>
    </section>
    <section data-title="Example code - contract">
        <p>Contracts help to clearly express generic intention behind interface:
            <code>[ContractClassFor(typeof(IFibonacci))]
abstract class FibonacciContract : IFibonacci
{
	public int GetNthFibonacci(int n)
	{
		Requires(n &gt;= 0);
        Ensures(<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(Result<span class="irrelevant">&lt;int&gt;()</span>));
		Ensures(n &gt; 1 || Result<span class="irrelevant">&lt;int&gt;()</span> == n);
        Ensures(n &lt; 2 || Enumerable.Range(0, Result<span class="irrelevant">&lt;int&gt;()</span> + 1).Count(m =&gt; <span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(m)) == n);<span class="irrelevant">
        return default(int);</span>
	}

	public int GetNextFibonacci(int n)
	{
		Requires(<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(n));
		Ensures(Result<span class="irrelevant">&lt;int&gt;()</span> &gt; n);
		Ensures(<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(Result<span class="irrelevant">&lt;int&gt;()</span>));
		Ensures(ForAll(n + 1, Result<span class="irrelevant">&lt;int&gt;()</span>, m =&gt; !<span class="irrelevant">((IFibonacci)this).</span>IsFibonacci(m)));<span class="irrelevant">
		return default(int);</span>
	}
}
</code></p>
    </section>
	<section data-title="Contracts and Unit Tests">
		<style>
			section table th {
				text-align: center;
			}

			section table {
				width: 100%;
				table-layout: fixed;
			}
			section table td {
                vertical-align: top;
                padding-right: 3em;
			}
			section table td:before {
/*                content: '\2022';*/
                content: '\25A0';
                font-size: 0.6em;
                vertical-align: bottom;
			}
		</style>
		<table>
			<tr>
				<th>Contracts</th>
				<th>Unit Tests</th>
			</tr>
			<tr>
				<td>
					Specify generic requirements
				</td>
				<td>
					Check specific example usages
				</td>
			</tr>
			<tr>
				<td>
					Can be defined on public and private methods
				</td>
				<td>
					Check only public methods
				</td>
			</tr>
			<tr>
				<td>
					Checked during unit tests, debug sessions, manual exploratory tests, with static analyzer or even on production
				</td>
				<td>
					Have to be ran explicitly
				</td>
			</tr>
			<tr>
				<td>
                    1:1 mapping with implementing methods
				</td>
				<td>
                    No direct mapping with implementing methods
				</td>
			</tr>
			<tr>
				<td>
					Can target interfaces and check all their implementations
				</td>
				<td>
					Can only target specific class
				</td>
			</tr>
			<tr>
				<td>
					Check pre- and post-conditions
				</td>
				<td>
					Check only postconditions
				</td>
			</tr>
		</table>
	</section>
	<section data-title="History">
		<ul>
			<li>Developed in 2008 at <a href="https://www.microsoft.com/en-us/research/group/research-in-software-engineering-rise/" data-footnote="microsoft.com/.../research-in-software-engineering-rise">Software Engineering division of Microsoft Research (RiSE)</a></li>
            <li>Designed to improve testing, static analysis, and generation of documentation</li>
            <li>Open sourced (MIT License) and <a href="https://github.com/Microsoft/CodeContracts" data-footnote="github.com/Microsoft/CodeContracts">released on GitHub</a></li>
            <li><a href="http://referencesource.microsoft.com/#mscorlib/system/diagnostics/contracts/contracts.cs" data-footnote="referencesource.microsoft.com/#mscorlib/system/diagnostics/contracts/contracts.cs">Added to Base Class Library</a>, used internally in <a href="http://referencesource.microsoft.com/#mscorlib/system/array.cs,2904" data-footnote="referencesource.microsoft.com/#mscorlib/system/array.cs">.NET Framework</a> and <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Array.cs#L52" data-footnote="dotnet/coreclr/.../mscorlib/src/System/Array.cs">Core</a></li>
<!--            <li><a href="https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET" data-footnote="marketplace.visualstudio.com/.../CodeContractsforNET">RiSE toolset supports only full .NET Framework and Visual Studio 2015 and below</a></li>-->
<!--            <li>Source code repository contains implementation of <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Diagnostics/Contracts/Contracts.cs" data-footnote="github.com/dotnet/coreclr/.../System/Diagnostics/Contracts/Contracts.cs">Contracts class</a> and <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Diagnostics/Contracts/ContractsBCL.cs" data-footnote="github.com/dotnet/coreclr/.../System/Diagnostics/Contracts/ContractsBCL.cs">failure handling code for runtime checking</a></li>-->
<!--            <li>This code can only be used internally by framework, and for applications stub is exposed trough package <a href="https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.Contracts/ref/System.Diagnostics.Contracts.cs" data-footnote="github.com/dotnet/corefx/.../System.Diagnostics.Contracts.cs">System.Diagnostics.Contracts</a> instead</li>-->
            <li><a href="https://github.com/Microsoft/CodeContracts/issues/409" data-footnote="github.com/Microsoft/CodeContracts/issues/409">Microsoft is not working on .NET Core compatible toolset</a></li>
<!--            <li><a href="https://github.com/dotnet/roslyn" data-footnote="github.com/dotnet/roslyn">Microsoft.CodeAnalysis (aka Roslyn)</a> or <a href="https://github.com/Fody/Fody" data-footnote="github.com/Fody/Fody">Fody</a> may help with modern re-implementation</li>-->
		</ul>
	</section>
	<section data-title="Contract packages">
		<ul>
            <li><strong><a href="https://www.nuget.org/packages/DotNet.Contracts/" data-footnote="nuget.org/packages/DotNet.Contracts">DotNet.Contracts</a></strong>
				<ul>
					<li>Documentation generator, rewriter, static and runtime checker</li>
					<li>Visual Studio extension: <a href="https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET">RiSEResearchinSoftwareEngineering.CodeContractsforNET</a></li>
					<li>Incompatible with .NET Core and VS2017+</li>
<!--					<li>Source: <a href="https://github.com/Microsoft/CodeContracts">github.com/Microsoft/CodeContracts</a></li>-->
				</ul>
			</li>
			<li><strong><a href="https://www.nuget.org/packages/System.Diagnostics.Contracts/" data-footnote="nuget.org/packages/System.Diagnostics.Contracts">System.Diagnostics.Contracts</a></strong>
				<ul>
					<li>Just stubbed interface</li>
					<li>.NET Core compatible</li>
<!--					<li>Source: <a href="https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.Contracts/ref/System.Diagnostics.Contracts.cs">github.com/dotnet/corefx/.../System.Diagnostics.Contracts.cs</a></li>-->
				</ul>
			</li>
			<li><strong>DotNet.Core.Contracts</strong>
				<ul>
<!--					<li>.NET Core compatible</li>-->
					<li>Interface, rewriter, and runtime checker</li>
					<li>Does not exist yet, can be developed by community with Roslyn or Fody</li>
				</ul>
			</li>
		</ul>
	</section>
	<section data-title="Contract method stubs">
		<style>
			section[data-title="Contract method stubs"] code {
				font-size: 0.8em;
				display: inline-block;
			}
		</style>
		<center>
			<code><!--// The .NET Foundation licenses this file to you under the MIT license.
-->namespace <strong>System.Diagnostics.Contracts</strong>
{
    public static class <strong>Contract</strong>
    {
        event EventHandler&lt;ContractFailedEventArgs&gt; <span class="hljs-title"><strong>ContractFailed</strong></span> <span class="irrelevant" data-replacement=";">{ add { } remove { } }</span>
        void <strong>Assert</strong>(bool condition<span class="irrelevant">, string userMessage</span>) <span class="irrelevant" data-replacement=";">{ }</span>
        void <strong>Assume</strong>(bool condition<span class="irrelevant">, string userMessage</span>) <span class="irrelevant" data-replacement=";">{ }</span>
        void <strong>Ensures</strong>(bool condition<span class="irrelevant">, string userMessage</span>) <span class="irrelevant" data-replacement=";">{ }</span>
        void <span class="hljs-title"><strong>EnsuresOnThrow</strong></span>&lt;TException&gt;(bool condition<span class="irrelevant">, string userMessage</span>)
            where TException : Exception <span class="irrelevant">{ }</span>
        bool <span class="hljs-title"><strong>Exists</strong></span>&lt;T&gt;(IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate) <span class="irrelevant" data-replacement=";">{ return false; }</span>
        bool <span class="hljs-title"><strong>ForAll</strong></span>&lt;T&gt;(IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate) <span class="irrelevant" data-replacement=";">{ return false; }</span>
        void <strong>Invariant</strong>(bool condition<span class="irrelevant">, string userMessage</span>) <span class="irrelevant" data-replacement=";">{ }</span>
        T <span class="hljs-title"><strong>OldValue&lt;T&gt;</strong></span>(T value) <span class="irrelevant" data-replacement=";">{ return default(T); }</span>
        void <strong>Requires</strong>(bool condition<span class="irrelevant">, string userMessage</span>) <span class="irrelevant" data-replacement=";">{ }</span><!--
        void <span class="hljs-title"><strong>Requires&lt;TException&gt;</strong></span>(bool condition, string userMessage)
            where TException : Exception <span class="irrelevant">{ }</span> -->
        T <span class="hljs-title"><strong>Result</strong></span>&lt;T&gt;() <span class="irrelevant" data-replacement=";">{ return default(T); }</span>
        T <span class="hljs-title"><strong>ValueAtReturn</strong></span>&lt;T&gt;(out T value) <span class="irrelevant" data-replacement=";">{ value = default(T); return value; }</span>
    }<!--
    public class <strong>Pure</strong>Attribute : Attribute { }-->
}</code>
		</center>
	</section>
	<section data-title="Contract method stubs cont.">
		<ul>
			<li>Designed to do nothing when runtime checking is off (no performance overhead!)</li>
			<li>Assertion methods are compiled conditionally:
				<code>[<strong>Conditional</strong>("DEBUG"), <strong>Conditional</strong>("CONTRACTS_FULL")]
void Ensures(bool condition, string userMessage) {...}</code></li>
			<li>Helper methods should only be used as their inline parameters:
				<code>// returns, so cannot be [Conditional]
<strong>bool</strong> <span class="hljs-title">ForAll&lt;T&gt;</span>(IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate) {...}
Contract.Requires(<strong>Contract.ForAll&lt;int&gt;(inputs, i => i > 0)</strong>); // both will be either rewritten or omitted</code></li>
			<li>"Hacking" Contract methods to run <strong>without rewriter</strong> results in unspecified behaviour:
				<code>bool inputsValid <strong>= Contract.ForAll&lt;int&gt;</strong>(inputs, i => i == i); // ERROR (may e.g. throw or always return false)
<strong>#define DEBUG
#define CONTRACTS_FULL</strong>
Contract.Requires(true); // ERROR (may e.g. do nothing, throw or fail assertion)</code></li>
		</ul>
	</section>
	<section data-title="Static checker">
		<ul>
			<li>Integrated with IDE (VS 2010-2015, produces ReSharper-like warnings)</li>
			<li>Suggests contracts where they are not declared but can be deduced (implicit contracts):
				<code>CodeContracts: Suggested requires: Contract.Requires(inputArray != null);</code></li>
			<li>Code is not needed to be ran at all</li>
			<li>Reports contract violations that are <b>possible</b> according to structure of the code</li>
			<li>Because of this, it also produces false-positives (as opposite to runtime checker)</li>
		</ul>
	</section>
	<section data-title="Contract rewriter">
		<ul>
			<li>Is required for runtime checking</li>
			<li>Injects ContractsRuntime class into assembly</li>
			<li>Replaces calls to Contract.* by calls to ContractsRuntime.*, passing both boolean expression and its code as a string</li>
			<li>Transforms contracts validated at method exit into more complex generated code:
				<ul>
					<li>Ensures, EnsuresOnThrow</li>
					<li>Invariant</li>
					<li>Result</li>
				</ul>
			</li>
			<li>Inlines ValueAtReturn and code marked with ContractClassFor or ContractAbbreviator</li>
		</ul>
	</section>
	<section data-title="Control flow transforms">
		<ul>
			<!--TODO: symbolical diagrams representing those, text left as a comment-->
			<li>Control flow is modified to use generated helper local variable for storing result and single return statement at the
				end of method</li>
			<li>Contract.Ensures is checked before that single return statement</li>
			<li>Contract.EnsuresOnThrow causes whole method body to be wrapped in try block and is checked in its catch block</li>
			<li>Contract.Invariant is checked at the end of each public method</li>
		</ul>
	</section>
	<section data-title="Control flow transforms - cont.">
		<ul>
			<li>Contract.Result is already moved to the end of method with enclosing Ensures and replaced by reference to previously generated
				result variable, that is going to be returned afterwards</li>
			<li>Contract.ValueAtReturn is moved the same way as Result, and replaced by reference passed to it as parameter (theoretically
				it could be any expression, as its literally executed just before return)</li>
			<li>ContractClassFor attribute causes all method bodies in type marked with it to be prepended to their counterparts in type
				passed as parameter to it</li>
			<li>ContractAbbreviator attribute causes body of method marked with it to be inlined in place of calls to it, so that it can
				contain contract shared by multiple methods</li>
		</ul>
	</section>
	<section data-title="Runtime internals">
		<ul>
			<li>ContractsRuntime methods do actual check and react on failure
				<ul>
					<li><a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Diagnostics/Contracts/ContractsBCL.cs#L295" data-footnote="dotnet/coreclr/.../System/Diagnostics/Contracts/ContractsBCL/RaiseContractFailedEventImplementation">call System.Runtime.CompilerServices.ContractHelper.RaiseContractFailedEvent</a></li>
					<li>which calls registered handlers and <a href="https://github.com/dotnet/coreclr/blob/master/src/vm/eepolicy.cpp#L1556" data-footnote="dotnet/coreclr/../vm/eepolicy/HandleCodeContractFailure">runtime-specific method</a> (e.g. displaying assertion error window)</li>
					<li>if not handled, throws System.Diagnostics.Contracts.ContractsRuntime.ContractException containing string representation of failed contract</li>
				</ul>
			</li>
		</ul>
	</section>
    <section data-title=".NET Core toolset with Roslyn">
        <a href="https://github.com/dotnet/roslyn/wiki/Getting-Started-C%23-Syntax-Transformation" data-footnote="github.com/dotnet/roslyn/wiki/Getting Started C# Syntax Transformation">Roslyn (Microsoft.CodeAnalysis.CSharp) allows transformations of textual C# source code</a>:
        <code>partial class ContractRewriter : CSharpSyntaxRewriter // transforms e.g.: Contract.Requires(n > 0) to ContractRuntime.Requires(n > 0, "n > 0");
{
    public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        return IsContract(node) ? Rewrite(node) : node; // IsContract uses CSharpCompilation and SemanticModel
    }

    private SyntaxNode Rewrite(InvocationExpressionSyntax node)
    {
        var oldReference = ((MemberAccessExpressionSyntax)node.Expression).Expression;
        var conditionTextArgument = SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(
            SyntaxKind.StringLiteralExpression,
            SyntaxFactory.Literal(node.ArgumentList.Arguments.First().GetText().ToString())));
        return node
            .ReplaceNode(oldReference, SyntaxFactory.ParseExpression(typeof(ContractsRuntime).FullName))
            .WithArgumentList(node.ArgumentList.AddArguments(conditionTextArgument));
    }
    
    public static string Rewrite(string code)
    {
        return new ContractRewriter().Visit(CSharpSyntaxTree.ParseText(code).GetRoot()).ToFullString();
    }
}</code>
    </section>
</body>

</html>
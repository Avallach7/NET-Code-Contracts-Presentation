<!DOCTYPE html>
<html lang="en">

<head>
    <title>.NET Code Contracts</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="template/layout.css" rel="stylesheet">
    <link href="template/theme.css" rel="stylesheet">
    <script src="template/switcher.js"></script>
</head>

<body>
    <section class="title">
        <h1>.NET Code Contracts</h1>
    </section>
    <section data-title="Contract packages">
        <ul>
            <li>System.Diagnostics.Contracts
                <ul>
                    <li>Contract method stubs</li>
                    <li>Source: github.com/dotnet/corefx/.../System.Diagnostics.Contracts</li>
                </ul>
            </li>
            <li>DotNet.Contracts
                <ul>
                    <li>Static checker</li>
                    <li>Binarty rewriter</li>
                    <li>Documentation generator</li>
                    <li>VS extension: <a href="https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET">RiSEResearchinSoftwareEngineering.CodeContractsforNET</a></li>
                    <li>Source: github.com/Microsoft/CodeContracts</li>
                </ul>
            </li>
        </ul>
    </section>
    <section data-title="Contract method stubs" class="code">
        <style>
            section[data-title="Contract method stubs"].code {
                text-align: center;
            }
            
            section[data-title="Contract method stubs"].code code {
                font-size: 0.4em;
                display: inline-block;
            }
        </style>
        <code>// The .NET Foundation licenses this file to you under the MIT license.

namespace <strong>System.Diagnostics.Contracts</strong>
{
    public static class <strong>Contract</strong>
    {
        event EventHandler&lt;ContractFailedEventArgs&gt; <strong>ContractFailed</strong> { add { } remove { } }
        void <strong>Assert</strong>(bool condition, string userMessage) { }
        void <strong>Assume</strong>(bool condition, string userMessage) { }
        void <strong>Ensures</strong>(bool condition, string userMessage) { }
        void <strong>EnsuresOnThrow&lt;TException&gt;</strong>(bool condition, string userMessage)
            where TException : Exception { }
        bool <strong>Exists&lt;T&gt;</strong>(IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate) { throw null; }
        bool <strong>ForAll&lt;T&gt;</strong>(IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate) { throw null; }
        void <strong>Invariant</strong>(bool condition, string userMessage) { }
        T <strong>OldValue&lt;T&gt;</strong>(T value) { throw null; }
        void <strong>Requires</strong>(bool condition, string userMessage) { }
        void <strong>Requires&lt;TException&gt;</strong>(bool condition, string userMessage) 
            where TException : Exception { }
        T <strong>Result&lt;T&gt;</strong>() { throw null; }
        T <strong>ValueAtReturn&lt;T&gt;</strong>(out T value) { throw null; }
    }
    public class <strong>Pure</strong>Attribute : Attribute { }
}</code>
    </section>
    <section data-title="Contract method stubs">
        <ul>
            <li>Designed to do nothing when contracts are not rewritten</li>
            <li>Assertion methods are empty and compiled conditionally:
                <code>[<strong>Conditional</strong>("DEBUG"), <strong>Conditional</strong>("CONTRACTS_FULL")]
void Ensures(bool condition, string userMessage) <strong>{ }</strong></code></li>
            <li>Helper methods throw if called without being rewritten:
            <code>// returns, so cannot be [Conditional]
<strong>bool</strong> ForAll&lt;T&gt;(IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate) <strong>{ throw null; }</strong></code></li>
            <li>That's why they should only be used as inline parameters to assertions:
            <code>Contract.Requires(<strong>Contract.ForAll&lt;int&gt;(inputs, i => i > 0)</strong>); // OK, will be rewritten or omitted
bool inputsValid = <strong>Contract.ForAll&lt;int&gt;(inputs, i => i > 0)</strong>; //ERROR, would throw without rewriting
</code></li>
        </ul>
    </section>
    <section data-title="Static checker">
        <ul>
            <li>Integrated with IDE (VS 2010-2015, produces ReSharper-like warnings)</li>
            <li>Suggests contracts where they are not declared but can be deduced (implicit contracts):
<code>CodeContracts: Suggested requires: Contract.Requires(inputArray != null);</code></li>
        </ul>
    </section>
    <section data-title=".NET Core support">
        <ul>
            <li>Microsoft doesn't plan to maintain toolset for .NET Core - just interface</li>
            <li>Port / reimplementation by community is needed</li>
            <li>Using Roslyn (Microsoft.CodeAnalysis @ NuGet) could help a lot</li>
            <li>Fody (based on Mono.Cecil and Microsoft.Build.Framework) allows similar IL modifications</li>
        </ul>
    </section>
</body>

</html>
